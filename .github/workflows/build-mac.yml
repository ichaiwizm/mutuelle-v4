# Ce workflow build l'app Electron sur macOS et produit un .dmg
# Il se d√©clenche quand tu push un tag "v*" (ex: v0.1.0-beta.1)

name: Build Mac

on:
  # D√©clench√© quand tu push un tag commen√ßant par "v"
  # Ex: git tag v0.1.0-beta.1 && git push origin v0.1.0-beta.1
  push:
    tags:
      - 'v*'

  # Permet aussi de lancer manuellement depuis l'onglet Actions de GitHub
  workflow_dispatch:

jobs:
  build-mac:
    # Utilise un runner macOS h√©berg√© par GitHub (gratuit pour repos publics, 2000 min/mois pour priv√©s)
    runs-on: macos-latest

    steps:
      # 1. R√©cup√®re le code source
      - name: Checkout code
        uses: actions/checkout@v4

      # 2. Installe Node.js (m√™me version que tu utilises en local)
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      # 3. Installe pnpm (version d√©finie dans package.json via packageManager)
      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      # 4. Cache les d√©pendances pour acc√©l√©rer les builds suivants
      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ~/.pnpm-store
          key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-

      # 5. Installe les d√©pendances Node.js
      - name: Install dependencies
        run: pnpm install

      # 6. Rebuild better-sqlite3 pour l'architecture Mac (arm64 ou x64)
      # C'est un module natif qui doit √™tre compil√© pour chaque plateforme
      - name: Rebuild native modules
        run: pnpm rebuild

      # 7. Installe Chromium via Playwright et le copie pour le bundler
      # Playwright installe Chromium dans ~/Library/Caches/ms-playwright/
      # On le copie dans .playwright-browsers/ pour qu'electron-builder le bundle
      - name: Install Playwright Chromium
        run: npx playwright install chromium

      - name: Copy Chromium for bundling
        run: |
          # Trouve le dossier Chromium install√© par Playwright
          PLAYWRIGHT_CACHE="$HOME/Library/Caches/ms-playwright"
          CHROMIUM_FOLDER=$(ls -d "$PLAYWRIGHT_CACHE"/chromium-* 2>/dev/null | head -1)

          if [ -z "$CHROMIUM_FOLDER" ]; then
            echo "‚ùå Chromium not found in $PLAYWRIGHT_CACHE"
            ls -la "$PLAYWRIGHT_CACHE" || true
            exit 1
          fi

          echo "‚úÖ Found Chromium: $CHROMIUM_FOLDER"

          # Copie dans le dossier qui sera bundl√©
          mkdir -p .playwright-browsers
          cp -R "$CHROMIUM_FOLDER" .playwright-browsers/

          echo "üì¶ Copied to .playwright-browsers/"
          ls -la .playwright-browsers/

      # 8. Debug: V√©rifie les credentials Apple (sans r√©v√©ler les secrets)
      - name: Debug Apple credentials
        run: |
          echo "=== Checking Apple credentials format ==="
          echo "APPLE_ID length: ${#APPLE_ID}"
          echo "APPLE_ID starts with: ${APPLE_ID:0:3}***"
          echo "APPLE_APP_SPECIFIC_PASSWORD length: ${#APPLE_APP_SPECIFIC_PASSWORD}"
          echo "APPLE_APP_SPECIFIC_PASSWORD format check (should be xxxx-xxxx-xxxx-xxxx):"
          if [[ "$APPLE_APP_SPECIFIC_PASSWORD" =~ ^[a-z]{4}-[a-z]{4}-[a-z]{4}-[a-z]{4}$ ]]; then
            echo "‚úÖ Password format looks correct"
          else
            echo "‚ùå Password format might be wrong. Expected: xxxx-xxxx-xxxx-xxxx (lowercase letters)"
          fi
          echo "APPLE_TEAM_ID length: ${#APPLE_TEAM_ID}"
          echo "APPLE_TEAM_ID: $APPLE_TEAM_ID"

          echo ""
          echo "=== Testing notarytool credentials ==="
          xcrun notarytool history --apple-id "$APPLE_ID" --password "$APPLE_APP_SPECIFIC_PASSWORD" --team-id "$APPLE_TEAM_ID" 2>&1 || echo "‚ùå Credential test failed"
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

      # 9. Build l'app Electron et cr√©e le .dmg sign√© (sans attendre la notarization)
      - name: Build and package
        run: pnpm dist:mac
        timeout-minutes: 30
        env:
          # Signature de code Apple (certificat Developer ID Application)
          CSC_LINK: ${{ secrets.CSC_LINK }}
          CSC_KEY_PASSWORD: ${{ secrets.CSC_KEY_PASSWORD }}
          # Notarization Apple
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          # Credentials Google OAuth inject√©s au build via electron-vite define
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          # Token GitHub pour electron-builder
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # 10. Attendre et v√©rifier la notarization (avec timeout de 15 min)
      - name: Wait for notarization
        run: |
          echo "=== Checking notarization status ==="
          # R√©cup√®re le dernier submission ID
          SUBMISSION_INFO=$(xcrun notarytool history \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --output-format json 2>/dev/null | head -1)

          SUBMISSION_ID=$(echo "$SUBMISSION_INFO" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data['history'][0]['id'])" 2>/dev/null || echo "")

          if [ -z "$SUBMISSION_ID" ]; then
            echo "‚ö†Ô∏è Could not find submission ID, skipping notarization wait"
            exit 0
          fi

          echo "Submission ID: $SUBMISSION_ID"

          # Attend jusqu'√† 15 minutes
          for i in {1..30}; do
            STATUS=$(xcrun notarytool info "$SUBMISSION_ID" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_APP_SPECIFIC_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" \
              --output-format json 2>/dev/null | python3 -c "import sys, json; print(json.load(sys.stdin)['status'])" 2>/dev/null || echo "Unknown")

            echo "Attempt $i/30 - Status: $STATUS"

            if [ "$STATUS" = "Accepted" ]; then
              echo "‚úÖ Notarization successful!"
              # Staple the DMG
              xcrun stapler staple release/*.dmg || true
              exit 0
            elif [ "$STATUS" = "Invalid" ] || [ "$STATUS" = "Rejected" ]; then
              echo "‚ùå Notarization failed with status: $STATUS"
              xcrun notarytool log "$SUBMISSION_ID" \
                --apple-id "$APPLE_ID" \
                --password "$APPLE_APP_SPECIFIC_PASSWORD" \
                --team-id "$APPLE_TEAM_ID" || true
              exit 1
            fi

            sleep 30
          done

          echo "‚ö†Ô∏è Notarization still in progress after 15 minutes"
          echo "The DMG is signed but not yet notarized. Users will need to right-click -> Open"
          exit 0
        timeout-minutes: 20
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

      # 9. Upload le .dmg comme "artifact" t√©l√©chargeable
      # Tu pourras le r√©cup√©rer depuis l'onglet Actions de GitHub
      - name: Upload DMG artifact
        uses: actions/upload-artifact@v4
        with:
          name: Mutuelle-mac
          path: release/*.dmg
          retention-days: 30  # Gard√© 30 jours

      # 10. Si c'est un tag, cr√©e aussi une Release GitHub avec le .dmg attach√©
      # Tes beta testeurs pourront t√©l√©charger depuis la page Releases
      - name: Create GitHub Release
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v1
        with:
          files: release/*.dmg
          draft: true  # Cr√©√© en brouillon pour que tu puisses v√©rifier avant de publier
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
